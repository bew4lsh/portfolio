---
interface Props {
  id: string;
  data: any[];
  layout?: any;
  config?: any;
  height?: string;
  width?: string;
  className?: string;
}

const { 
  id, 
  data, 
  layout = {}, 
  config = {},
  height = '400px',
  width = '100%',
  className = ''
} = Astro.props;
---

<div 
  id={id}
  class={`plotly-chart ${className}`}
  style={`height: ${height}; width: ${width}; min-height: ${height};`}
  data-plotly-data={JSON.stringify(data)}
  data-plotly-layout={JSON.stringify(layout)}
  data-plotly-config={JSON.stringify(config)}
>
  <!-- Loading skeleton -->
  <div class="chart-loading">
    <div class="loading-skeleton">
      <div class="skeleton-title"></div>
      <div class="skeleton-chart"></div>
    </div>
  </div>
</div>

<script>
  import { createThemedPlotlyConfig, getCurrentThemeColors } from '../utils/plotlyTheme.ts';
  
  // Plotly chart initialization with comprehensive theming
  function initializePlotlyChart(container) {
    try {
      const rawData = JSON.parse(container.dataset.plotlyData);
      const customLayout = JSON.parse(container.dataset.plotlyLayout);
      const customConfig = JSON.parse(container.dataset.plotlyConfig);
      
      // Create fully themed configuration
      const { data, layout, config } = createThemedPlotlyConfig(rawData, customLayout, customConfig);
      
      // Remove loading skeleton
      const loadingEl = container.querySelector('.chart-loading');
      if (loadingEl) {
        loadingEl.remove();
      }
      
      // Create the plot with themed configuration
      window.Plotly.newPlot(container, data, layout, config);
      
      // Handle theme changes dynamically
      const handleThemeChange = () => {
        try {
          // Re-create themed configuration with current theme
          const { data: newData, layout: newLayout } = createThemedPlotlyConfig(
            rawData, 
            customLayout, 
            customConfig
          );
          
          // Update the chart with new themed data and layout
          window.Plotly.react(container, newData, newLayout, config);
        } catch (error) {
          console.warn('Failed to update chart theme:', error);
        }
      };
      
      // Watch for theme changes via DOM class changes
      const observer = new MutationObserver((mutations) => {
        const hasThemeChange = mutations.some(mutation => 
          mutation.type === 'attributes' && 
          mutation.attributeName === 'class' &&
          (mutation.target.className.includes('theme-') || mutation.target.className.includes('theme-dark'))
        );
        
        if (hasThemeChange) {
          handleThemeChange();
        }
      });
      
      observer.observe(document.documentElement, { 
        attributes: true, 
        attributeFilter: ['class'] 
      });
      
      // Listen for custom theme change events (for programmatic theme changes)
      document.addEventListener('theme-changed', handleThemeChange);
      
    } catch (error) {
      console.error('Failed to initialize Plotly chart:', error);
      container.innerHTML = '<div class="chart-error">Failed to load chart</div>';
    }
  }
  
  // Initialize charts when Plotly is loaded and DOM is ready
  function initializeAllCharts() {
    const charts = document.querySelectorAll('.plotly-chart');
    
    charts.forEach(chart => {
      // Use intersection observer for performance - only load charts when they're visible
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            initializePlotlyChart(entry.target);
            observer.unobserve(entry.target);
          }
        });
      }, {
        rootMargin: '100px' // Start loading slightly before chart comes into view
      });
      
      observer.observe(chart);
    });
  }
  
  // Wait for both DOM and Plotly to be available
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeAllCharts);
  } else {
    initializeAllCharts();
  }
</script>

<style>
  .plotly-chart {
    background: var(--gray-999);
    border-radius: 0.75rem;
    border: 1px solid var(--gray-800);
    overflow: hidden;
    position: relative;
  }
  
  .chart-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    width: 100%;
  }
  
  .loading-skeleton {
    width: 90%;
    height: 90%;
    padding: 1rem;
  }
  
  .skeleton-title {
    height: 24px;
    background: linear-gradient(90deg, var(--gray-800) 25%, var(--gray-700) 50%, var(--gray-800) 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    border-radius: 4px;
    margin-bottom: 1rem;
    width: 60%;
  }
  
  .skeleton-chart {
    height: calc(100% - 40px);
    background: linear-gradient(90deg, var(--gray-800) 25%, var(--gray-700) 50%, var(--gray-800) 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    border-radius: 8px;
  }
  
  @keyframes loading {
    0% {
      background-position: 200% 0;
    }
    100% {
      background-position: -200% 0;
    }
  }
  
  .chart-error {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--gray-400);
    font-style: italic;
  }
  
  /* Responsive adjustments */
  @media (max-width: 50em) {
    .plotly-chart {
      border-radius: 0.5rem;
    }
  }
</style>